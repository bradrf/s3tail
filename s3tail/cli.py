'''
Utility to help "tail" AWS logs stored in S3 generated by S3 bucket
logging or ELB logging.
'''
from builtins import object

import os
import sys
import signal
import errno
import logging
import re
import click

from boto import s3
from configstruct import ConfigStruct

from .s3tail import S3Tail

# TODO:
# * consider support for reading from multiple buckets?

DEFAULTS = {
    'log_level': 'info',
    'log_file': 'STDERR',
    'cache_path': os.path.join(os.path.expanduser('~'), '.s3tailcache'),
    'cache_hours': 24,
}

CONTEXT_SETTINGS = dict(help_option_names=['-h', '--help'])
@click.command(context_settings=CONTEXT_SETTINGS)
@click.version_option()
@click.option('-c', '--config-file', type=click.Path(dir_okay=False, writable=True),
              default=os.path.join(os.path.expanduser('~'), '.s3tailrc'),
              help='Configuration file', show_default=True)
@click.option('-r', '--region', type=click.Choice(r.name for r in s3.regions()),
              help='AWS region to use when connecting')
@click.option('-b', '--bookmark', help='Bookmark to start at (key:line or a named bookmark)')
@click.option('-l', '--log-level', type=click.Choice(['debug','info','warning','error','critical']),
              help='set logging level')
@click.option('--log-file', metavar='FILENAME', help='write logs to FILENAME')
@click.option('--cache-hours', type=int,
              help='Number of hours to keep in cache before removing on next run (0 disables caching)')
@click.option('--cache-lookup', is_flag=True,
              help='Report if s3_uri keys are cached (showing pathnames if found)')
@click.argument('s3_uri')
def main(config_file, region, bookmark, log_level, log_file, cache_hours, cache_lookup, s3_uri):
    '''Begins tailing files found at [s3://]BUCKET[/PREFIX]
    (automatically decompressing any ending in ".gz")
    '''

    config = ConfigStruct(config_file, options=DEFAULTS)
    opts = config.options

    # let command line options have temporary precedence if provided values
    opts.might_prefer(region=region, log_level=log_level, log_file=log_file, cache_hours=cache_hours)

    s3_uri = re.sub(r'^(s3:)?/+', '', s3_uri)
    bucket, prefix = s3_uri.split('/', 1)

    log_kwargs = {
        'level': getattr(logging, opts.log_level.upper()),
        'format': '[%(asctime)s #%(process)d] %(levelname)-8s %(name)-12s %(message)s',
        'datefmt': '%Y-%m-%dT%H:%M:%S%z',
    }
    if opts.log_file != 'STDERR':
        log_kwargs['filename'] = opts.log_file
    logging.basicConfig(**log_kwargs)
    logger = logging.getLogger(__name__)

    class Track(object):
        tail = None
        last_key = None
        last_num = None
        show_pick_up = bookmark != None

    def progress(key, cache_pn, cached):
        Track.last_key = key
        if cache_lookup:
            prefix = '  => '
            click.echo(key)
            if not cached:
                click.echo(prefix + click.style('NOT IN CACHE', fg='red'))
            else:
                click.echo(prefix + click.style(cache_pn, fg='green'))
            return False
        else:
            logger.info('Starting %s', key)
            return True

    def dump(num, line):
        Track.last_num = num
        if Track.show_pick_up:
            logger.info('Picked up at line %s', num)
            Track.show_pick_up = False
        click.echo(line)

    tail = S3Tail(config, bucket, prefix, dump,
                  key_handler=progress, bookmark=bookmark,
                  region=opts.region, cache_path=opts.cache_path, hours=opts.cache_hours)

    signal.signal(signal.SIGINT, tail.stop)
    signal.signal(signal.SIGTERM, tail.stop)
    signal.signal(signal.SIGPIPE, tail.stop)

    try:
        tail.watch()
    except KeyboardInterrupt:
        signal_handler(signal.SIGINT, _)
    except IOError as exc:
        if exc.errno != errno.EPIPE: raise
        # just exit if piped to something that has terminated (i.e. head or tail)
    finally:
        tail.cleanup()

    if Track.last_key and Track.last_num:
        logger.info('Stopped processing at %s:%d', Track.last_key, Track.last_num)
    if Track.last_key or Track.last_num:
        logger.info('Bookmark: %s', tail.get_bookmark())

    sys.exit(0)

if __name__ == '__main__':
    main()
